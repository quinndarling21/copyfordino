{"ast":null,"code":"import _slicedToArray from \"/Users/quinndarling/Desktop/beartracks/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport shallowEqual from 'shallowequal';\nimport invariant from 'invariant';\nimport hoistStatics from 'hoist-non-react-statics';\nimport { DndContext } from '../index';\nimport { isPlainObject } from '../utils/js_utils';\nimport { Disposable, CompositeDisposable, SerialDisposable } from './disposables';\nimport { isRefable } from './utils';\nexport default function decorateHandler({\n  DecoratedComponent,\n  createHandler,\n  createMonitor,\n  createConnector,\n  registerHandler,\n  containerDisplayName,\n  getType,\n  collect,\n  options\n}) {\n  const _options$arePropsEqua = options.arePropsEqual,\n        arePropsEqual = _options$arePropsEqua === void 0 ? shallowEqual : _options$arePropsEqua;\n  const Decorated = DecoratedComponent;\n  const displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';\n\n  class DragDropContainer extends React.Component {\n    constructor(props) {\n      super(props);\n      this.decoratedRef = React.createRef();\n\n      this.handleChange = () => {\n        const nextState = this.getCurrentState();\n\n        if (!shallowEqual(nextState, this.state)) {\n          this.setState(nextState);\n        }\n      };\n\n      this.disposable = new SerialDisposable();\n      this.receiveProps(props);\n      this.dispose();\n    }\n\n    getHandlerId() {\n      return this.handlerId;\n    }\n\n    getDecoratedComponentInstance() {\n      invariant(this.decoratedRef.current, 'In order to access an instance of the decorated component, it must either be a class component or use React.forwardRef()');\n      return this.decoratedRef.current;\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n      return !arePropsEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);\n    }\n\n    componentDidMount() {\n      this.disposable = new SerialDisposable();\n      this.currentType = undefined;\n      this.receiveProps(this.props);\n      this.handleChange();\n    }\n\n    componentDidUpdate(prevProps) {\n      if (!arePropsEqual(this.props, prevProps)) {\n        this.receiveProps(this.props);\n        this.handleChange();\n      }\n    }\n\n    componentWillUnmount() {\n      this.dispose();\n    }\n\n    receiveProps(props) {\n      if (!this.handler) {\n        return;\n      }\n\n      this.handler.receiveProps(props);\n      this.receiveType(getType(props));\n    }\n\n    receiveType(type) {\n      if (!this.handlerMonitor || !this.manager || !this.handlerConnector) {\n        return;\n      }\n\n      if (type === this.currentType) {\n        return;\n      }\n\n      this.currentType = type;\n\n      const _registerHandler = registerHandler(type, this.handler, this.manager),\n            _registerHandler2 = _slicedToArray(_registerHandler, 2),\n            handlerId = _registerHandler2[0],\n            unregister = _registerHandler2[1];\n\n      this.handlerId = handlerId;\n      this.handlerMonitor.receiveHandlerId(handlerId);\n      this.handlerConnector.receiveHandlerId(handlerId);\n      const globalMonitor = this.manager.getMonitor();\n      const unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, {\n        handlerIds: [handlerId]\n      });\n      this.disposable.setDisposable(new CompositeDisposable(new Disposable(unsubscribe), new Disposable(unregister)));\n    }\n\n    dispose() {\n      this.disposable.dispose();\n\n      if (this.handlerConnector) {\n        this.handlerConnector.receiveHandlerId(null);\n      }\n    }\n\n    getCurrentState() {\n      if (!this.handlerConnector) {\n        return {};\n      }\n\n      const nextState = collect(this.handlerConnector.hooks, this.handlerMonitor, this.props);\n\n      if (process.env.NODE_ENV !== 'production') {\n        invariant(isPlainObject(nextState), 'Expected `collect` specified as the second argument to ' + '%s for %s to return a plain object of props to inject. ' + 'Instead, received %s.', containerDisplayName, displayName, nextState);\n      }\n\n      return nextState;\n    }\n\n    render() {\n      return React.createElement(DndContext.Consumer, null, ({\n        dragDropManager\n      }) => {\n        this.receiveDragDropManager(dragDropManager);\n\n        if (typeof requestAnimationFrame !== 'undefined') {\n          requestAnimationFrame(() => this.handlerConnector.reconnect());\n        }\n\n        return React.createElement(Decorated, Object.assign({}, this.props, this.getCurrentState(), {\n          // NOTE: if Decorated is a Function Component, decoratedRef will not be populated unless it's a refforwarding component.\n          ref: isRefable(Decorated) ? this.decoratedRef : null\n        }));\n      });\n    }\n\n    receiveDragDropManager(dragDropManager) {\n      if (this.manager !== undefined) {\n        return;\n      }\n\n      invariant(dragDropManager !== undefined, 'Could not find the drag and drop manager in the context of %s. ' + 'Make sure to wrap the top-level component of your app with DragDropContext. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/troubleshooting#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);\n\n      if (dragDropManager === undefined) {\n        return;\n      }\n\n      this.manager = dragDropManager;\n      this.handlerMonitor = createMonitor(dragDropManager);\n      this.handlerConnector = createConnector(dragDropManager.getBackend());\n      this.handler = createHandler(this.handlerMonitor, this.decoratedRef);\n    }\n\n  }\n\n  DragDropContainer.DecoratedComponent = DecoratedComponent;\n  DragDropContainer.displayName = \"\".concat(containerDisplayName, \"(\").concat(displayName, \")\");\n  return hoistStatics(DragDropContainer, DecoratedComponent);\n}","map":null,"metadata":{},"sourceType":"module"}