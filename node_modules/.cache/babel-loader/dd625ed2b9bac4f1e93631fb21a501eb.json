{"ast":null,"code":"export default class MonotonicInterpolant {\n  constructor(xs, ys) {\n    const length = xs.length; // Rearrange xs and ys so that xs is sorted\n\n    const indexes = [];\n\n    for (let i = 0; i < length; i++) {\n      indexes.push(i);\n    }\n\n    indexes.sort((a, b) => xs[a] < xs[b] ? -1 : 1); // Get consecutive differences and slopes\n\n    const dys = [];\n    const dxs = [];\n    const ms = [];\n    let dx;\n    let dy;\n\n    for (let i = 0; i < length - 1; i++) {\n      dx = xs[i + 1] - xs[i];\n      dy = ys[i + 1] - ys[i];\n      dxs.push(dx);\n      dys.push(dy);\n      ms.push(dy / dx);\n    } // Get degree-1 coefficients\n\n\n    const c1s = [ms[0]];\n\n    for (let i = 0; i < dxs.length - 1; i++) {\n      const m2 = ms[i];\n      const mNext = ms[i + 1];\n\n      if (m2 * mNext <= 0) {\n        c1s.push(0);\n      } else {\n        dx = dxs[i];\n        const dxNext = dxs[i + 1];\n        const common = dx + dxNext;\n        c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));\n      }\n    }\n\n    c1s.push(ms[ms.length - 1]); // Get degree-2 and degree-3 coefficients\n\n    const c2s = [];\n    const c3s = [];\n    let m;\n\n    for (let i = 0; i < c1s.length - 1; i++) {\n      m = ms[i];\n      const c1 = c1s[i];\n      const invDx = 1 / dxs[i];\n      const common = c1 + c1s[i + 1] - m - m;\n      c2s.push((m - c1 - common) * invDx);\n      c3s.push(common * invDx * invDx);\n    }\n\n    this.xs = xs;\n    this.ys = ys;\n    this.c1s = c1s;\n    this.c2s = c2s;\n    this.c3s = c3s;\n  }\n\n  interpolate(x) {\n    const xs = this.xs,\n          ys = this.ys,\n          c1s = this.c1s,\n          c2s = this.c2s,\n          c3s = this.c3s; // The rightmost point in the dataset should give an exact result\n\n    let i = xs.length - 1;\n\n    if (x === xs[i]) {\n      return ys[i];\n    } // Search for the interval x is in, returning the corresponding y if x is one of the original xs\n\n\n    let low = 0;\n    let high = c3s.length - 1;\n    let mid;\n\n    while (low <= high) {\n      mid = Math.floor(0.5 * (low + high));\n      const xHere = xs[mid];\n\n      if (xHere < x) {\n        low = mid + 1;\n      } else if (xHere > x) {\n        high = mid - 1;\n      } else {\n        return ys[mid];\n      }\n    }\n\n    i = Math.max(0, high); // Interpolate\n\n    const diff = x - xs[i];\n    const diffSq = diff * diff;\n    return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}